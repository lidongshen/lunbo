黄色叹号：编译警告（可以忽略），解决方法：第一种：压制。第二种：根据警告的提示做相应的处理

泛型：
	class A<T> T类型：type 对所有类型的统称
	
	A<String> a = new A<String>("UEK");//创建一个带有类型的类的对象，要求要传递一种类型。
	a.toString();
	
	在声明一个方法时，可以给该方法传递一个参数，而该参数必须是一个值。
	而在泛型中，作为参数传递的是一种类型，该类型默认是Object；这种传递的方式，可以用在类、接口、方法中。
	不管基本数据类型还是引用类型，方法的传递就是值的传递。
	
	泛型好处：
		1.在声明集合时，要求指定存储元素的数据类型。List<String> list = new ArrayList<String>();
		虽然集合的功能比较强大，可以存储任意的数据类型。但是，本身是存在着数据安全隐患。
		因为在开发过程中，我们一般会对数据结构规范，要求一种数据结构只存储一种数据类型.
		
		2）减少了类型转换的次数，提高了效率；
		没有使用泛型：String --->Object --->String;
		使用泛型：String--->String--->String;
		3）减少编译警告；
		（JDK1.7之后：对泛型添加了自动推断的功能）
		
		注意：Set set = new HashSet<String>(); 该语法虽然添加了泛型类型，但是无效。
	
	/**
		 * 泛型的4种语法：
		 */
		//JDK1.7之前的语法： 最规范的语法 , 推荐使用
		Set<String> set = new HashSet<String>();
		Map<String , String> map = new HashMap<String , String>();
		
		//JDK1.7之后的语法： 对于泛型添加了 自动推断类型的功能
		Set<String> set1 = new HashSet<>();
		set1.add("uek");
		//set1.add(100);
		
		//了解即可;
		Set<String> set2 = new HashSet();
		set2.add("uek");
		//set2.add(100);
		
		//该语法虽然添加了泛型的类型，但是无效；该语法了解即可；
		Set set3 = new HashSet<String>();
		set3.add("uek");
		set3.add(100);
		System.out.println(set3);
		
		
IO流：
	input  output
	分类：
		1）按照流的方向：
			输入流
			输出流
		2）按照流的单位：
			字节流：
			字符流：
		3）按照功能：
			节点流：最基础的流，功能比较单一；
			处理流：在节点流的基础上进行功能增强；
	
	IO流API体系：  在java.io包下；
					在IO流中由四个抽象类来进行组织： 
						1)InputStream  :字节输入流的父类  
							子类：	FileInputStream从文件系统中的某个文件中获得输入字节。
								ObjectInputStream：将已经序列化的进行反序列化。
							              		 序列化：将对象的数据从内存写到磁盘
							       		 反序列化：从磁盘上读取对象的数据到内存
									BufferinputStream:自带一个缓冲区的字节输入流
						 2）OutputStream:字节输出流的父类
					             		 子类：    FileOutputStream：输出字节到文件系统中的某个文件中。
								ObjectOutputStream：将对象进行序列化。
									序列化：将对象的数据从内存写到磁盘
									反序列化：从磁盘上读取对象的数据到内存
								BufferOutputStream:自带一个缓冲区的字节输出流
						 3）Reader:用于读取字符流的抽象类
							子类：	FileReader:文件字符输入流
								BufferedReader:自带缓存区的字符输入流
				                                4）Writer:用于输出字符流的抽象类
					                               子类：	FileWriter:字符输出流
								BufferedWriter:自带一个缓冲区的字符输出流
						对于字符流来说，要求数据源和程序的编码格式保持一致，否则出现乱码。
		FileInputStream:字节流
				构造器：FileInputStream(String name) 通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的路径名 name 指定。
					路径写法：\\ --> \ 或可以使用/（跨平台用法）
				读取数据：.read()  返回int值 文件中字符对应的（ASCII表）十进制数的值   没有数据返回-1.
							while((date = .read())!= -1){}
						（推荐使用）第二种：手动添加缓冲区。
								byte[] buf = new byte[1024];//缓存区的大小根据读取数据量来。
								read(byte[] b) 从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。
								while((date = .read(byte[] b))!= -1){String str = new String(b,0,b.length);//将一个字节数组中指定的范围内的元素转成字符串
							第三种： read(byte[] b,int off, int len)

				关闭流：.close;
					
		FileOutputStream：字节流
				构造器：FileOutputStream(String name) 创建一个向具有指定名称的文件中写入数据的输出文件流。
				输出数据：
						第一种：write(int b) 将指定字节写入此文件输出流。
								.write('a');							
						第二种：write(byte[] b)  将 b.length 个字节从指定 byte 数组写入此文件输出流中
								String str = "abc"; str.getByted();  转换成字节数组
						第三种：write(byte[] b, int off, int len) 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此文件输出流
								
				关闭:.close;
		
		FileReader：字符流。
				构造器：FileReader(String fileName) 在给定从中读取数据的文件名的情况下创建一个新 FileReader。
				读取数据：
					第一种：int temp = 0; while((temp = .read())!=-1){  }
					第二种：char[] buf = new char[1024]; int temp = 0;  while((temp = fr.read(buf))!=-1){ String str =new String(buf,0,temp)  };
					
		FileWrite：字符流。  必须关闭，否则数据写不到目的地。close()先溢写，再关闭。flush()刷新后可以不用关闭。
				构造器：FileWriter(String fileName) 根据给定的文件名构造一个 FileWriter 对象。
				输出数据：
						第一种：.write()
						第二种：char[] charArr = "avsddf".toCharArray();write(charArr,0,3);

		BufferedInputStream  BufferedOutputStream  :缓冲流（处理流）
				BufferedInputStream br = new BufferedInputStream(new FileInputStream("2.txt"));
				BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("1.txt"));
				int temp = 0;
				byte[] by = new byte[1024];
				while ((temp = br.read(by)) != -1) {
					bos.write(by, 0, temp);
				}
				bos.close();
				br.close();

		BufferedReader    BufferedWriter ：
				BufferedReader br = new BufferedReader(new FileReader("2.txt"));
				BufferedWriter bw = new BufferedWriter(new FileWriter("1.txt"));
				/*
				 * int temp = 0; char[] charArr = new char[1024]; 
				 * while ((temp =br.read(charArr)) != -1) { bw.write(charArr, 0, temp); }
				 */
				String str = null;
				while ((str = br.readLine()) != null) {
					bw.write(str);
					bw.newLine();
				}
				bw.close();
				br.close();





